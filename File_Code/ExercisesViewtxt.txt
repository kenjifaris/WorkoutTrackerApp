Attached is are the photos of my overall project and the firebase database console. Also, please note that the new data we are using is under the collection name 'exercises' in the firestore database. The old data we were using was under the collection 'public' in firestore database. To reiterate, we are using the data that is in the collection 'exercises' in the firestore database. Please review the following code to the files and remember all of this for future reference. 



'AdminExerciseManagerView'

import SwiftUI
import Firebase
import FirebaseFirestore

struct AdminExerciseManagerView: View {
    @State private var exercises: [ExerciseModel] = []
    @State private var selectedExercises: Set<String> = []
    @State private var editedNames: [String: String] = [:]
    @State private var editedBodyParts: [String: String] = [:]
    @State private var editedEquipments: [String: String] = [:]

    var body: some View {
        NavigationView {
            VStack {
                // Button to trigger the JSON upload to Firestore
                Button("Upload JSON to Firestore") {
                    FirestoreService.shared.uploadJSONDataToFirestore()
                }
                .padding()
                .background(Color.green)
                .foregroundColor(.white)
                .cornerRadius(10)

                // Existing bulk update button
                Button("Run Bulk Update") {
                    FirestoreService.shared.bulkUpdateExerciseNames()
                }
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)

                // New button to match GIFs to exercises
                Button("Match GIFs to Exercises") {
                    FirestoreService.shared.matchGifsToExercises()
                }
                .padding()
                .background(Color.orange)
                .foregroundColor(.white)
                .cornerRadius(10)

                List {
                    ForEach(exercises, id: \.id) { exercise in
                        HStack {
                            // Display exercise image or GIF
                            if let gifFileName = exercise.gifFileName,
                               let gifPath = Bundle.main.path(forResource: gifFileName, ofType: nil, inDirectory: "360"),
                               let image = UIImage(contentsOfFile: gifPath) {
                                Image(uiImage: image)
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: 50, height: 50)
                                    .cornerRadius(8)
                            } else {
                                Image(systemName: "photo")
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: 50, height: 50)
                                    .foregroundColor(.gray)
                            }

                            VStack(alignment: .leading) {
                                TextField(exercise.name, text: Binding(
                                    get: { editedNames[exercise.id] ?? exercise.name },
                                    set: { editedNames[exercise.id] = $0 }
                                ))
                                .textFieldStyle(RoundedBorderTextFieldStyle())

                                TextField(exercise.bodyPart, text: Binding(
                                    get: { editedBodyParts[exercise.id] ?? exercise.bodyPart },
                                    set: { editedBodyParts[exercise.id] = $0 }
                                ))
                                .textFieldStyle(RoundedBorderTextFieldStyle())
                                .foregroundColor(.gray)

                                TextField(exercise.equipment, text: Binding(
                                    get: { editedEquipments[exercise.id] ?? exercise.equipment },
                                    set: { editedEquipments[exercise.id] = $0 }
                                ))
                                .textFieldStyle(RoundedBorderTextFieldStyle())
                                .foregroundColor(.gray)
                            }

                            Spacer()

                            Button(action: {
                                toggleSelection(for: exercise)
                            }) {
                                Image(systemName: selectedExercises.contains(exercise.id) ? "checkmark.circle.fill" : "circle")
                                    .foregroundColor(selectedExercises.contains(exercise.id) ? .blue : .gray)
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                .navigationTitle("Admin Exercise Manager")
                .onAppear {
                    loadData()
                }
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Save Changes") {
                            saveSelectedExercises()
                        }
                    }
                    ToolbarItem(placement: .navigationBarLeading) {
                        Button("Duplicate Document") {
                            duplicateDocument(from: "user_exercises", to: "user_exercises_4", in: "public")
                        }
                    }
                }
            }
        }
    }

    private func loadData() {
        fetchExercises()
        fetchSelectedExercises()
    }

    private func fetchExercises() {
        ExerciseDBService().fetchAllExercises { result in
            switch result {
            case .success(let exercises):
                DispatchQueue.main.async {
                    self.exercises = exercises
                }
            case .failure(let error):
                print("Failed to fetch exercises: \(error)")
            }
        }
    }

    private func fetchSelectedExercises() {
        let db = Firestore.firestore()
        let docRef = db.collection("exercises").document("user_exercises")

        docRef.getDocument { document, error in
            if let document = document, document.exists {
                if let data = document.data(), let savedExercises = data["exercises"] as? [[String: Any]] {
                    DispatchQueue.main.async {
                        self.selectedExercises = Set(savedExercises.compactMap { $0["id"] as? String })
                    }
                }
            } else {
                print("No document found or error: \(error?.localizedDescription ?? "Unknown error")")
            }
        }
    }


    private func toggleSelection(for exercise: ExerciseModel) {
        if selectedExercises.contains(exercise.id) {
            selectedExercises.remove(exercise.id)
        } else {
            selectedExercises.insert(exercise.id)
        }
        
        saveSelectedExercises()
    }

    private func saveSelectedExercises() {
        let db = Firestore.firestore()
        let selectedExerciseModels = exercises.filter { selectedExercises.contains($0.id) }
        do {
            let data = try JSONEncoder().encode(selectedExerciseModels)
            if let exercisesDict = try JSONSerialization.jsonObject(with: data, options: .fragmentsAllowed) as? [[String: Any]] {
                db.collection("exercises").document("user_exercises").setData(["exercises": exercisesDict]) { error in
                    if let error = error {
                        print("Failed to save exercises to Firebase: \(error)")
                    } else {
                        print("Exercises successfully saved to Firebase")
                    }
                }
            }
        } catch {
            print("Failed to encode exercises: \(error)")
        }
    }


    private func duplicateDocument(from sourceDocID: String, to targetDocID: String, in collection: String) {
        let db = Firestore.firestore()
        let sourceDocRef = db.collection(collection).document(sourceDocID)
        let targetDocRef = db.collection(collection).document(targetDocID)
        
        sourceDocRef.getDocument { (document, error) in
            if let document = document, document.exists {
                if let data = document.data() {
                    targetDocRef.setData(data) { error in
                        if let error = error {
                            print("Error duplicating document: \(error.localizedDescription)")
                        } else {
                            print("Document successfully duplicated!")
                        }
                    }
                }
            } else {
                print("Source document does not exist or failed to fetch: \(error?.localizedDescription ?? "Unknown error")")
            }
        }
    }
}

// Preview
struct AdminExerciseManagerView_Previews: PreviewProvider {
    static var previews: some View {
        AdminExerciseManagerView()
    }
}


'ExercisesView'

import SwiftUI
import Firebase
import FirebaseFirestore

struct ExercisesView: View {
    @State private var exercises: [ExerciseModel] = []
    @State private var filteredExercises: [ExerciseModel] = []
    @State private var searchText: String = ""
    @State private var selectedBodyPart: String? = nil
    @State private var selectedEquipment: String? = nil
    @State private var selectedExercises: [ExerciseModel] = []
    @State private var isLoading = false
    @State private var selectedExercise: ExerciseModel?

    // State to manage sheet presentation
    @State private var isBodyPartSheetPresented = false
    @State private var isEquipmentSheetPresented = false
    @State private var bodyParts: [String] = []
    @State private var equipments: [String] = []

    // Mapping dictionaries to condense categories
    private let equipmentMapping: [String: String] = [
        "Elliptical Machine": "Machine",
        "Leverage Machine": "Machine",
        "Sled Machine": "Machine",
        "Stepmill Machine": "Machine",
        "Stationary Bike": "Machine",
        "Hammer": "Other",
        "Trap Bar": "Other",
        "Rope": "Other",
        "Wheel Roller": "Other",
    ]
    
    private let bodyPartMapping: [String: String] = [
        "Lower Legs": "Legs",
        "Upper Legs": "Legs",
        "Lower Arms": "Arms",
        "Upper Arms": "Arms",
        "Waist": "Core",
    ]

    var body: some View {
        NavigationView {
            VStack {
                // Search Bar
                SearchBar(text: $searchText, onTextChanged: filterExercises)
                    .padding(.top)

                // Filter Buttons
                HStack(spacing: 16) {
                    Button(action: fetchBodyParts) {
                        Text(selectedBodyPart ?? "Body Part")
                            .font(.subheadline)
                            .padding()
                            .background(Color.gray.opacity(0.2))
                            .cornerRadius(10)
                    }
                    .sheet(isPresented: $isBodyPartSheetPresented) {
                        List {
                            Button("Body Part") {
                                selectedBodyPart = nil
                                filterExercises(searchText)
                                isBodyPartSheetPresented = false
                            }
                            ForEach(bodyParts, id: \.self) { part in
                                Button(part) {
                                    selectedBodyPart = part
                                    filterExercises(searchText)
                                    isBodyPartSheetPresented = false
                                }
                            }
                        }
                    }

                    Button(action: fetchEquipments) {
                        Text(selectedEquipment ?? "Equipment")
                            .font(.subheadline)
                            .padding()
                            .background(Color.gray.opacity(0.2))
                            .cornerRadius(10)
                    }
                    .sheet(isPresented: $isEquipmentSheetPresented) {
                        List {
                            Button("Equipment") {
                                selectedEquipment = nil
                                filterExercises(searchText)
                                isEquipmentSheetPresented = false
                            }
                            ForEach(equipments, id: \.self) { equipment in
                                Button(equipment) {
                                    selectedEquipment = equipment
                                    filterExercises(searchText)
                                    isEquipmentSheetPresented = false
                                }
                            }
                        }
                    }
                }
                .padding(.horizontal)
                .padding(.bottom, 8)

                // Exercise List
                List(filteredExercises) { exercise in
                    HStack {
                        ExerciseRowView(exercise: exercise)

                        Spacer()

                        // Info button to view exercise details
                        Button(action: {
                            selectedExercise = exercise
                        }) {
                            Image(systemName: "info.circle")
                                .foregroundColor(.blue)
                                .font(.title2)
                        }
                    }
                    .padding(.vertical, 5)
                }

                // Selected Exercises Summary
                if !selectedExercises.isEmpty {
                    HStack {
                        Text("Selected: \(selectedExercises.count) Exercises")
                            .font(.headline)
                        Spacer()
                        Button(action: finalizeWorkout) {
                            Text("Finalize")
                                .font(.headline)
                                .foregroundColor(.blue)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                }
            }
            .navigationTitle("Exercises")
            .onAppear(perform: loadExercisesFromFirebase) // Load from Firestore
            .sheet(item: $selectedExercise) { exercise in
                ExerciseDetailView(exercise: exercise)
            }
        }
    }

    // Fetch body parts from Firestore
    private func fetchBodyParts() {
        let db = Firestore.firestore()
        db.collection("exercises").getDocuments { (snapshot, error) in
            guard let snapshot = snapshot else {
                print("Failed to fetch body parts: \(error?.localizedDescription ?? "Unknown error")")
                return
            }
            var bodyPartsSet = Set<String>()
            for document in snapshot.documents {
                if let bodyPart = document.data()["bodyPart"] as? String {
                    let mappedBodyPart = bodyPartMapping[bodyPart] ?? bodyPart
                    bodyPartsSet.insert(mappedBodyPart)
                }
            }
            DispatchQueue.main.async {
                self.bodyParts = Array(bodyPartsSet).sorted()
                self.isBodyPartSheetPresented = true // Show sheet after fetching data
            }
        }
    }

    // Fetch equipment from Firestore
    private func fetchEquipments() {
        let db = Firestore.firestore()
        db.collection("exercises").getDocuments { (snapshot, error) in
            guard let snapshot = snapshot else {
                print("Failed to fetch equipment: \(error?.localizedDescription ?? "Unknown error")")
                return
            }
            var equipmentsSet = Set<String>()
            for document in snapshot.documents {
                if let equipment = document.data()["equipment"] as? String {
                    let mappedEquipment = equipmentMapping[equipment] ?? equipment
                    equipmentsSet.insert(mappedEquipment)
                }
            }
            DispatchQueue.main.async {
                self.equipments = Array(equipmentsSet).sorted()
                self.isEquipmentSheetPresented = true // Show sheet after fetching data
            }
        }
    }

    // Filter exercises
    private func filterExercises(_ text: String) {
        filteredExercises = exercises.filter { exercise in
            let mappedBodyPart = bodyPartMapping[exercise.bodyPart] ?? exercise.bodyPart
            let mappedEquipment = equipmentMapping[exercise.equipment] ?? exercise.equipment
            let matchesBodyPart = selectedBodyPart == nil || mappedBodyPart == selectedBodyPart
            let matchesEquipment = selectedEquipment == nil || mappedEquipment == selectedEquipment
            let matchesText = text.isEmpty || exercise.name.lowercased().contains(text.lowercased())

            return matchesBodyPart && matchesEquipment && matchesText
        }
    }

    // Load exercises from Firestore
    private func loadExercisesFromFirebase() {
        let db = Firestore.firestore()
        db.collection("exercises").getDocuments { (snapshot, error) in
            guard let snapshot = snapshot else {
                print("Failed to fetch exercises: \(error?.localizedDescription ?? "Unknown error")")
                return
            }
            do {
                let exercises = try snapshot.documents.compactMap { document -> ExerciseModel? in
                    return try? document.data(as: ExerciseModel.self)
                }
                DispatchQueue.main.async {
                    self.exercises = exercises
                    self.filteredExercises = exercises
                }
            } catch {
                print("Failed to decode exercises: \(error)")
            }
        }
    }

    private func addExercise(_ exercise: ExerciseModel) {
        if !selectedExercises.contains(exercise) {
            selectedExercises.append(exercise)
        }
    }

    private func finalizeWorkout() {
        // Navigate to a summary page or perform the desired action
    }
}

struct ExercisesView_Previews: PreviewProvider {
    static var previews: some View {
        ExercisesView()
    }
}


'ExerciseDetailView'

import SwiftUI
import SDWebImageSwiftUI

struct ExerciseDetailView: View {
    var exercise: ExerciseModel

    var body: some View {
        VStack {
            // TabView to switch between About, History, Charts, PRs
            TabView {
                VStack {
                    // Display the GIF using SDWebImageSwiftUI with local file
                    if let gifFileName = exercise.gifFileName,
                       let gifPath = Bundle.main.path(forResource: gifFileName, ofType: nil),
                       let gifUrl = URL(string: gifPath) {
                        WebImage(url: gifUrl)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .padding()
                    }
                    
                    // Display the instructions
                    Text("Instructions")
                        .font(.headline)
                        .padding(.top)
                    
                    ForEach(exercise.instructions ?? [], id: \.self) { instruction in
                        Text(instruction)
                            .padding(.vertical, 2)
                    }
                }
                .tabItem {
                    Label("About", systemImage: "info.circle")
                }
                
                // Other tabs (History, Charts, PRs)
                Text("History Content")
                    .tabItem {
                        Label("History", systemImage: "clock.arrow.circlepath")
                    }
                
                Text("Charts Content")
                    .tabItem {
                        Label("Charts", systemImage: "chart.bar")
                    }
                
                Text("PRs Content")
                    .tabItem {
                        Label("PRs", systemImage: "rosette")
                    }
            }
            .padding()
            .navigationTitle(exercise.name)
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}


'ExerciseModel'

import Foundation

struct ExerciseModel: Identifiable, Equatable, Codable {
    let id: String
    var name: String
    var target: String
    var bodyPart: String
    var equipment: String
    var category: String?
    var gifFileName: String?
    var secondaryMuscles: [String]?
    var instructions: [String]?

    static func == (lhs: ExerciseModel, rhs: ExerciseModel) -> Bool {
        return lhs.id == rhs.id
    }
}


'ExerciseRowView'

import SwiftUI

struct ExerciseRowView: View {
    let exercise: ExerciseModel

    var body: some View {
        HStack {
            if let gifFileName = exercise.gifFileName {
                // Use the folder reference path here
                let gifPath = Bundle.main.path(forResource: "360/\(gifFileName)", ofType: nil)
                
                if let gifPath = gifPath, let image = UIImage(contentsOfFile: gifPath) {
                    Image(uiImage: image)
                        .resizable()
                        .scaledToFit()
                        .frame(width: 50, height: 50)
                        .cornerRadius(8)
                } else {
                    Image(systemName: "photo")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 50, height: 50)
                        .foregroundColor(.gray)
                }
            } else {
                Image(systemName: "photo")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 50, height: 50)
                    .foregroundColor(.gray)
            }

            VStack(alignment: .leading, spacing: 4) {
                Text(exercise.name)
                    .font(.headline)
                
                Text(exercise.target)
                    .font(.subheadline)
                    .foregroundColor(.gray)
                
                Text(exercise.equipment)
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }

            Spacer()
        }
        .padding(.vertical, 8)
    }
}

struct ExerciseRowView_Previews: PreviewProvider {
    static var previews: some View {
        ExerciseRowView(exercise: ExerciseModel(
            id: "0001",
            name: "Push Up",
            target: "Chest",
            bodyPart: "Chest",
            equipment: "Body weight",
            category: "Strength",
            gifFileName: "0001.gif",
            secondaryMuscles: ["Triceps", "Shoulders"],
            instructions: [
                "Start in a high plank position with your hands placed slightly wider than shoulder-width apart.",
                "Lower your body until your chest nearly touches the floor.",
                "Push back up to the starting position.",
                "Repeat for the desired number of repetitions."
            ]
        ))
    }
}


'FirestoreService'


import Foundation
import FirebaseFirestore

class FirestoreService {
    static let shared = FirestoreService()
    
    private init() {}

    // Method to upload JSON data to Firestore (already done but included for reference)
    func uploadJSONDataToFirestore() {
        // This method would include the logic to upload JSON data to Firestore if needed.
    }
    
    // Method to bulk update exercise names (existing)
    func bulkUpdateExerciseNames() {
        // Existing bulk update method logic if required.
    }
    
    // Method to match GIFs to exercises
    func matchGifsToExercises() {
        let db = Firestore.firestore()
        let exercisesCollection = db.collection("exercises")

        exercisesCollection.getDocuments { snapshot, error in
            guard let documents = snapshot?.documents, error == nil else {
                print("Error fetching exercises: \(error?.localizedDescription ?? "Unknown error")")
                return
            }

            for document in documents {
                var exerciseData = document.data()
                if let exerciseId = exerciseData["id"] as? String {
                    let gifFileName = "\(exerciseId).gif"
                    
                    if Bundle.main.path(forResource: gifFileName, ofType: nil, inDirectory: "360") != nil {
                        exerciseData["gifFileName"] = gifFileName
                    } else {
                        print("GIF not found for exercise ID \(exerciseId)")
                    }

                    exercisesCollection.document(exerciseId).updateData(exerciseData) { error in
                        if let error = error {
                            print("Failed to update exercise \(exerciseId) with GIF: \(error.localizedDescription)")
                        } else {
                            print("Successfully updated exercise \(exerciseId) with GIF \(gifFileName)")
                        }
                    }
                }
            }
        }
    }
}

// Helper to convert the ExerciseModel to dictionary
extension ExerciseModel {
    var dictionary: [String: Any] {
        return [
            "id": id,
            "name": name,
            "target": target,
            "bodyPart": bodyPart,
            "equipment": equipment,
            "category": category ?? "",
            "gifFileName": gifFileName ?? "",
            "secondaryMuscles": secondaryMuscles ?? [],
            "instructions": instructions ?? []
        ]
    }
}